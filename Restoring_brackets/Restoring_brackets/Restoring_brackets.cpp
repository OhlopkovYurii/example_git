//Автор: Охлопков Юрий ИВТ-23

/*
* https://github.com/ivtipm/Data-structures-and-algorithms/blob/main/tasks/task_s1_dynamic_programming.md
*
*
Задача Восстановление скобок
Задан шаблон, состоящий из круглых скобок и знаков вопроса.
Требуется определить, сколькими способами можно заменить знаки вопроса
круглыми скобками так, чтобы получилось правильное скобочное выражение.
Входные данные Первая строка входного файла содержит заданный шаблон
длиной не более 80 символов. Выходные данные Выведите в выходной файл
искомое количество способов. Исходные данные будут таковы, что
это количество не превзойдет 2·109 .
Пример входного файла ????(?
Пример выходного файла 2

*/

#include <iostream>
#include "Restoring_brackets.h"
#include <cassert>
//#define MAX 2010
//Массив для хранения результатов динамического программирования.
// dp[n][k] хранит количество способов закончить шаблон, начиная с позиции n, 
// с балансом скобок k.
//k = количество открывающих скобок - количество закрывающих




///Рекурсивная функция, которая вычисляет кол-во способов 
/// заменить знаки вопроса круглыми скобками так, 
/// чтобы получилось правильное скобочное выражение
/// n - позиция с которой считываем символы в строке
/// k - количество открывающих скобок минус количество закрывающих
/// s- строка которую вводит пользователь
int f(int n, int k, string s)
{
    //Длина входной строки
    size_t len = s.size();
    int dp[MAX][MAX];
    //заполнение элементов массива dp значениями -1
    memset(dp, -1, sizeof(dp));


    //Если баланс скобок отрицательный(больше закрывающих, чем открывающих), 
    // то это неправильная последовательность возвращаем 0.
    if (k < 0) return 0;
    // Если мы достигли конца строки
    // то последовательность правильная только если баланс скобок равен 0 (k == 0).
    if (n == len) return (k == 0);

    // Мемоизация.Если значение dp[n][k] уже вычислено, 
    // возвращаем его, чтобы избежать повторных вычислений.
    if (dp[n][k] != -1) return dp[n][k];


    //Если текущий символ s[n] — открывающая скобка, увеличиваем баланс k на 1 
    // и рекурсивно вызываем функцию для следующей позиции.
    if (s[n] == '(') return dp[n][k] = f(n + 1, k + 1, s);

    //Если текущий символ s[n] — закрывающая скобка, уменьшаем баланс k на 1 
    // и рекурсивно вызываем функцию для следующей позиции.
    if (s[n] == ')') return dp[n][k] = f(n + 1, k - 1, s);

    //Если текущий символ s[n] — знак вопроса, 
    // мы можем заменить его либо на открывающую, либо на закрывающую скобку.
    // Поэтому суммируем результаты для обоих случаев.
    return dp[n][k] = f(n + 1, k - 1, s) + f(n + 1, k + 1, s);

}

///тесты
void all_assert()
{
    string s1 = "????(?";
    assert(f(0, 0, s1) == 2);

    string s2 = ")?((";
    assert(f(0, 0, s2) == 0);

    string s3 = "????";
    assert(f(0, 0, s3) == 2);


    string s4 = "!";
    assert(f(0, 0, s4) == 0);

    string s5 = "!";
    assert(f(0, 0, s5) == 0);
    
}